const express = require('express');
const fs = require('fs');
const path = require('path');
const moment = require('moment');
const cron = require('node-cron');
const { scrapingAdaptativo } = require('./seletor-dinamico-adaptativo');

// Inicializar o app Express
const app = express();
const PORT = process.env.PORT || 3000;

// Vari√°veis para controle de atualiza√ß√£o autom√°tica
let intervalAtualizacao = null;
let cronJobDiario = null;
let ultimaAtualizacao = null;
let statusAtualizacao = 'idle'; // idle, running, error

// Configura√ß√£o de atualiza√ß√£o autom√°tica (em minutos)
const INTERVALO_ATUALIZACAO = process.env.INTERVALO_ATUALIZACAO || 30; // 30 minutos por padr√£o

// Configura√ß√£o de atualiza√ß√£o di√°ria (hor√°rio da meia-noite)
const HORARIO_ATUALIZACAO_DIARIA = process.env.HORARIO_ATUALIZACAO_DIARIA || '0 0 * * *'; // Meia-noite por padr√£o

// Middleware para CORS - ESSENCIAL para acesso externo
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, User-Agent');
  
  // Log todas as requisi√ß√µes para debug
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url} - IP: ${req.ip || req.connection.remoteAddress}`);
  
  if (req.method === 'OPTIONS') {
    res.sendStatus(200);
  } else {
    next();
  }
});

// Middleware para parsing de JSON
app.use(express.json());

// Middleware para trust proxy (importante para servi√ßos de hospedagem)
app.set('trust proxy', true);

// Fun√ß√£o para verificar se um arquivo existe
function arquivoExiste(caminho) {
  try {
    return fs.existsSync(caminho);
  } catch (err) {
    console.error(`Erro ao verificar arquivo ${caminho}:`, err);
    return false;
  }
}

// Fun√ß√£o para obter o caminho do arquivo de jogos
function obterCaminhoArquivoJogos(data) {
  const dataFormatada = moment(data).format('YYYY-MM-DD');
  return path.join(__dirname, `jogos_${dataFormatada}.json`);
}

// Fun√ß√£o para obter dados de jogos (com fallback para dados de exemplo)
function obterDadosJogos(data = null) {
  const dataAtual = data ? moment(data).format('YYYY-MM-DD') : moment().format('YYYY-MM-DD');
  const caminhoArquivo = obterCaminhoArquivoJogos(dataAtual);
  
  if (arquivoExiste(caminhoArquivo)) {
    try {
      const dados = JSON.parse(fs.readFileSync(caminhoArquivo, 'utf8'));
      console.log(`Retornando dados reais para ${dataAtual} - ${dados.jogos ? dados.jogos.length : 0} jogos`);
      return dados;
    } catch (err) {
      console.error('Erro ao ler arquivo:', err);
    }
  }
  
  // Dados de exemplo mais realistas
  console.log(`Retornando dados de exemplo para ${dataAtual}`);
  return {
    data: dataAtual,
    totalJogos: 5,
    jogos: [
      {
        timeCasa: 'Flamengo',
        timeVisitante: 'Palmeiras',
        horario: '16:00',
        competicao: 'Campeonato Brasileiro',
        nivelCampeonato: 'S√©rie A',
        status: 'Agendado',
        placarCasa: '',
        placarVisitante: ''
      },
      {
        timeCasa: 'Real Madrid',
        timeVisitante: 'Barcelona',
        horario: '18:30',
        competicao: 'La Liga',
        nivelCampeonato: 'Primera Divisi√≥n',
        status: 'Agendado',
        placarCasa: '',
        placarVisitante: ''
      },
      {
        timeCasa: 'Manchester United',
        timeVisitante: 'Liverpool',
        horario: '21:00',
        competicao: 'Premier League',
        nivelCampeonato: 'First Division',
        status: 'Agendado',
        placarCasa: '',
        placarVisitante: ''
      },
      {
        timeCasa: 'Bayern Munich',
        timeVisitante: 'Borussia Dortmund',
        horario: '15:30',
        competicao: 'Bundesliga',
        nivelCampeonato: 'First Division',
        status: 'Agendado',
        placarCasa: '',
        placarVisitante: ''
      },
      {
        timeCasa: 'PSG',
        timeVisitante: 'Olympique Marseille',
        horario: '20:45',
        competicao: 'Ligue 1',
        nivelCampeonato: 'First Division',
        status: 'Agendado',
        placarCasa: '',
        placarVisitante: ''
      }
    ],
    observacao: 'Dados de exemplo - Execute o scraping para dados reais',
    servidor: 'API Deploy v1.0',
    timestamp: new Date().toISOString()
  };
}

// Fun√ß√£o para filtrar jogos
function filtrarJogos(jogos, filtros) {
  return jogos.filter(jogo => {
    // Filtro por competi√ß√£o
    if (filtros.competicao && !jogo.competicao.toLowerCase().includes(filtros.competicao.toLowerCase())) {
      return false;
    }
    
    // Filtro por n√≠vel
    if (filtros.nivel && jogo.nivelCampeonato && !jogo.nivelCampeonato.toLowerCase().includes(filtros.nivel.toLowerCase())) {
      return false;
    }
    
    // Filtro por time (casa ou visitante)
    if (filtros.time) {
      const timeFilter = filtros.time.toLowerCase();
      if (!jogo.timeCasa.toLowerCase().includes(timeFilter) && 
          !jogo.timeVisitante.toLowerCase().includes(timeFilter)) {
        return false;
      }
    }
    
    // Filtro por status
    if (filtros.status && jogo.status && !jogo.status.toLowerCase().includes(filtros.status.toLowerCase())) {
      return false;
    }
    
    return true;
  });
}

// Fun√ß√£o para obter competi√ß√µes √∫nicas
function obterCompeticoes(jogos) {
  const competicoes = [...new Set(jogos.map(jogo => jogo.competicao).filter(Boolean))];
  return competicoes.sort();
}

// Fun√ß√£o para obter n√≠veis √∫nicos
function obterNiveis(jogos) {
  const niveis = [...new Set(jogos.map(jogo => jogo.nivelCampeonato).filter(Boolean))];
  return niveis.sort();
}

// Fun√ß√£o para obter times √∫nicos
function obterTimes(jogos) {
  const times = new Set();
  jogos.forEach(jogo => {
    if (jogo.timeCasa) times.add(jogo.timeCasa);
    if (jogo.timeVisitante) times.add(jogo.timeVisitante);
  });
  return [...times].sort();
}

// Fun√ß√£o para executar atualiza√ß√£o autom√°tica
async function executarAtualizacaoAutomatica() {
  if (statusAtualizacao === 'running') {
    console.log('‚è≥ Atualiza√ß√£o j√° em andamento, pulando...');
    return;
  }

  try {
    statusAtualizacao = 'running';
    console.log('üîÑ Iniciando atualiza√ß√£o autom√°tica dos dados...');
    
    // Executar o scraping adaptativo
    await scrapingAdaptativo();
    
    ultimaAtualizacao = new Date();
    statusAtualizacao = 'idle';
    
    console.log(`‚úÖ Atualiza√ß√£o autom√°tica conclu√≠da √†s ${ultimaAtualizacao.toLocaleString('pt-BR')}`);
    
  } catch (erro) {
    statusAtualizacao = 'error';
    console.error('‚ùå Erro na atualiza√ß√£o autom√°tica:', erro.message);
    
    // Tentar novamente em 5 minutos em caso de erro
    setTimeout(() => {
      if (statusAtualizacao === 'error') {
        statusAtualizacao = 'idle';
      }
    }, 5 * 60 * 1000);
  }
}

// Fun√ß√£o para iniciar atualiza√ß√£o di√°ria √† meia-noite
function iniciarAtualizacaoDiaria() {
  if (cronJobDiario) {
    cronJobDiario.stop();
    cronJobDiario = null;
  }
  
  console.log(`üåô Configurando atualiza√ß√£o autom√°tica di√°ria √† meia-noite (${HORARIO_ATUALIZACAO_DIARIA})`);
  
  // Configurar cron job para executar √† meia-noite
  cronJobDiario = cron.schedule(HORARIO_ATUALIZACAO_DIARIA, async () => {
    console.log('üåô Executando atualiza√ß√£o autom√°tica di√°ria √† meia-noite...');
    await executarAtualizacaoAutomatica();
  }, {
    scheduled: true,
    timezone: 'America/Sao_Paulo'
  });
  
  console.log('‚úÖ Atualiza√ß√£o di√°ria configurada com sucesso!');
}

// Fun√ß√£o para iniciar atualiza√ß√£o autom√°tica (mantida para compatibilidade)
function iniciarAtualizacaoAutomatica() {
  if (intervalAtualizacao) {
    clearInterval(intervalAtualizacao);
  }
  
  console.log(`üïê Configurando atualiza√ß√£o autom√°tica a cada ${INTERVALO_ATUALIZACAO} minutos`);
  
  // Executar primeira atualiza√ß√£o ap√≥s 2 minutos do in√≠cio
  setTimeout(() => {
    executarAtualizacaoAutomatica();
  }, 2 * 60 * 1000);
  
  // Configurar intervalo de atualiza√ß√£o
  intervalAtualizacao = setInterval(() => {
    executarAtualizacaoAutomatica();
  }, INTERVALO_ATUALIZACAO * 60 * 1000);
}

// Fun√ß√£o para parar atualiza√ß√£o di√°ria
function pararAtualizacaoDiaria() {
  if (cronJobDiario) {
    cronJobDiario.stop();
    cronJobDiario = null;
    console.log('üõë Atualiza√ß√£o di√°ria parada');
  }
}

// Fun√ß√£o para parar atualiza√ß√£o autom√°tica (mantida para compatibilidade)
function pararAtualizacaoAutomatica() {
  if (intervalAtualizacao) {
    clearInterval(intervalAtualizacao);
    intervalAtualizacao = null;
    console.log('üõë Atualiza√ß√£o autom√°tica parada');
  }
}

// Rota raiz
app.get('/', (req, res) => {
  res.json({
    message: 'API de Jogos - Deploy Version Aprimorada com Atualiza√ß√£o Autom√°tica',
    version: '2.1.0',
    status: 'online',
    atualizacaoAutomatica: {
      ativo: intervalAtualizacao !== null,
      intervalo: `${INTERVALO_ATUALIZACAO} minutos`,
      status: statusAtualizacao,
      ultimaAtualizacao: ultimaAtualizacao ? ultimaAtualizacao.toISOString() : null
    },
    atualizacaoDiaria: {
      ativo: cronJobDiario !== null,
      horario: 'Meia-noite (00:00)',
      cronExpression: HORARIO_ATUALIZACAO_DIARIA,
      timezone: 'America/Sao_Paulo',
      status: statusAtualizacao,
      ultimaAtualizacao: ultimaAtualizacao ? ultimaAtualizacao.toISOString() : null
    },
    endpoints: [
      'GET / - Esta p√°gina',
      'GET /api/status - Status da API',
      'GET /api/jogos - Jogos da data atual',
      'GET /api/jogos/data/:data - Jogos de uma data espec√≠fica (YYYY-MM-DD)',
      'GET /api/jogos/competicao/:nome - Jogos de uma competi√ß√£o',
      'GET /api/jogos/nivel/:nome - Jogos de um n√≠vel de campeonato',
      'GET /api/jogos/time/:nome - Jogos de um time espec√≠fico',
      'GET /api/competicoes - Lista todas as competi√ß√µes',
      'GET /api/niveis - Lista todos os n√≠veis de campeonato',
      'GET /api/times - Lista todos os times',
      'POST /api/atualizar - Executar scraping manual',
      'POST /api/atualizar/iniciar - Iniciar atualiza√ß√£o autom√°tica',
      'POST /api/atualizar/parar - Parar atualiza√ß√£o autom√°tica',
      'POST /api/atualizar/diaria/iniciar - Iniciar atualiza√ß√£o di√°ria √† meia-noite',
      'POST /api/atualizar/diaria/parar - Parar atualiza√ß√£o di√°ria',
      'GET /health - Health check'
    ],
    filtros: {
      'Query Parameters': {
        'competicao': 'Filtrar por competi√ß√£o',
        'nivel': 'Filtrar por n√≠vel do campeonato',
        'time': 'Filtrar por time (casa ou visitante)',
        'status': 'Filtrar por status do jogo'
      },
      'Exemplos': [
        '/api/jogos?competicao=Copa',
        '/api/jogos?time=Flamengo',
        '/api/jogos/data/2025-07-30?competicao=Copa&time=Corinthians'
      ]
    },
    timestamp: new Date().toISOString()
  });
});

// Rota de health check (importante para servi√ßos de hospedagem)
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage()
  });
});

// Rota de status/health check
app.get('/api/status', (req, res) => {
  console.log('Health check solicitado');
  res.json({
    status: 'online',
    timestamp: new Date().toISOString(),
    servidor: 'API de Jogos - Deploy Version Aprimorada',
    versao: '2.1.0',
    uptime: process.uptime(),
    atualizacaoAutomatica: {
      ativo: intervalAtualizacao !== null,
      intervalo: `${INTERVALO_ATUALIZACAO} minutos`,
      status: statusAtualizacao,
      ultimaAtualizacao: ultimaAtualizacao ? ultimaAtualizacao.toISOString() : null,
      proximaAtualizacao: intervalAtualizacao && ultimaAtualizacao ? 
        new Date(ultimaAtualizacao.getTime() + (INTERVALO_ATUALIZACAO * 60 * 1000)).toISOString() : null
    },
    atualizacaoDiaria: {
      ativo: cronJobDiario !== null,
      horario: 'Meia-noite (00:00)',
      cronExpression: HORARIO_ATUALIZACAO_DIARIA,
      timezone: 'America/Sao_Paulo',
      status: statusAtualizacao,
      ultimaAtualizacao: ultimaAtualizacao ? ultimaAtualizacao.toISOString() : null,
      proximaAtualizacao: cronJobDiario ? 'Pr√≥xima meia-noite (00:00)' : null
    },
    endpoints: [
      'GET /api/status',
      'GET /api/jogos',
      'GET /api/jogos/data/:data',
      'GET /api/jogos/competicao/:nome',
      'GET /api/jogos/nivel/:nome',
      'GET /api/jogos/time/:nome',
      'GET /api/competicoes',
      'GET /api/niveis',
      'GET /api/times',
      'POST /api/atualizar',
      'POST /api/atualizar/iniciar',
      'POST /api/atualizar/parar',
      'POST /api/atualizar/diaria/iniciar',
      'POST /api/atualizar/diaria/parar'
    ],
    recursos: {
      'Filtros dispon√≠veis': ['competicao', 'nivel', 'time', 'status'],
      'Formatos de data': 'YYYY-MM-DD',
      'Query parameters': 'Suportados em todos os endpoints de jogos',
      'Atualiza√ß√£o autom√°tica': 'Configur√°vel via vari√°vel de ambiente INTERVALO_ATUALIZACAO',
      'Atualiza√ß√£o di√°ria': 'Executa automaticamente √† meia-noite (timezone: America/Sao_Paulo)'
    }
  });
});

// Rota para obter jogos da data atual (com filtros opcionais)
app.get('/api/jogos', (req, res) => {
  try {
    console.log('Solicita√ß√£o de jogos da data atual');
    const dados = obterDadosJogos();
    
    // Aplicar filtros se fornecidos
    const filtros = {
      competicao: req.query.competicao,
      nivel: req.query.nivel,
      time: req.query.time,
      status: req.query.status
    };
    
    if (Object.values(filtros).some(filtro => filtro)) {
      const jogosFiltrados = filtrarJogos(dados.jogos, filtros);
      return res.json({
        ...dados,
        totalJogos: jogosFiltrados.length,
        jogos: jogosFiltrados,
        filtrosAplicados: Object.fromEntries(Object.entries(filtros).filter(([k, v]) => v))
      });
    }
    
    return res.json(dados);
  } catch (erro) {
    console.error('Erro ao obter jogos:', erro);
    return res.status(500).json({ 
      erro: 'Erro interno do servidor', 
      detalhes: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para obter jogos de uma data espec√≠fica
app.get('/api/jogos/data/:data', (req, res) => {
  try {
    const { data } = req.params;
    
    // Validar formato da data
    if (!moment(data, 'YYYY-MM-DD', true).isValid()) {
      return res.status(400).json({
        erro: 'Formato de data inv√°lido',
        formato_esperado: 'YYYY-MM-DD',
        exemplo: '2025-07-30',
        timestamp: new Date().toISOString()
      });
    }
    
    console.log(`Solicita√ß√£o de jogos para data: ${data}`);
    const dados = obterDadosJogos(data);
    
    // Aplicar filtros se fornecidos
    const filtros = {
      competicao: req.query.competicao,
      nivel: req.query.nivel,
      time: req.query.time,
      status: req.query.status
    };
    
    if (Object.values(filtros).some(filtro => filtro)) {
      const jogosFiltrados = filtrarJogos(dados.jogos, filtros);
      return res.json({
        ...dados,
        totalJogos: jogosFiltrados.length,
        jogos: jogosFiltrados,
        filtrosAplicados: Object.fromEntries(Object.entries(filtros).filter(([k, v]) => v))
      });
    }
    
    return res.json(dados);
  } catch (erro) {
    console.error('Erro ao obter jogos por data:', erro);
    return res.status(500).json({ 
      erro: 'Erro interno do servidor', 
      detalhes: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para obter jogos por competi√ß√£o
app.get('/api/jogos/competicao/:nome', (req, res) => {
  try {
    const { nome } = req.params;
    const data = req.query.data;
    
    console.log(`Solicita√ß√£o de jogos da competi√ß√£o: ${nome}`);
    const dados = obterDadosJogos(data);
    
    const jogosFiltrados = filtrarJogos(dados.jogos, { competicao: nome });
    
    return res.json({
      ...dados,
      totalJogos: jogosFiltrados.length,
      jogos: jogosFiltrados,
      filtro: { competicao: nome }
    });
  } catch (erro) {
    console.error('Erro ao obter jogos por competi√ß√£o:', erro);
    return res.status(500).json({ 
      erro: 'Erro interno do servidor', 
      detalhes: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para obter jogos por n√≠vel
app.get('/api/jogos/nivel/:nome', (req, res) => {
  try {
    const { nome } = req.params;
    const data = req.query.data;
    
    console.log(`Solicita√ß√£o de jogos do n√≠vel: ${nome}`);
    const dados = obterDadosJogos(data);
    
    const jogosFiltrados = filtrarJogos(dados.jogos, { nivel: nome });
    
    return res.json({
      ...dados,
      totalJogos: jogosFiltrados.length,
      jogos: jogosFiltrados,
      filtro: { nivel: nome }
    });
  } catch (erro) {
    console.error('Erro ao obter jogos por n√≠vel:', erro);
    return res.status(500).json({ 
      erro: 'Erro interno do servidor', 
      detalhes: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para obter jogos por time
app.get('/api/jogos/time/:nome', (req, res) => {
  try {
    const { nome } = req.params;
    const data = req.query.data;
    
    console.log(`Solicita√ß√£o de jogos do time: ${nome}`);
    const dados = obterDadosJogos(data);
    
    const jogosFiltrados = filtrarJogos(dados.jogos, { time: nome });
    
    return res.json({
      ...dados,
      totalJogos: jogosFiltrados.length,
      jogos: jogosFiltrados,
      filtro: { time: nome }
    });
  } catch (erro) {
    console.error('Erro ao obter jogos por time:', erro);
    return res.status(500).json({ 
      erro: 'Erro interno do servidor', 
      detalhes: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para listar todas as competi√ß√µes
app.get('/api/competicoes', (req, res) => {
  try {
    const data = req.query.data;
    console.log('Solicita√ß√£o de lista de competi√ß√µes');
    const dados = obterDadosJogos(data);
    
    const competicoes = obterCompeticoes(dados.jogos);
    
    return res.json({
      total: competicoes.length,
      competicoes: competicoes,
      data: dados.data,
      timestamp: new Date().toISOString()
    });
  } catch (erro) {
    console.error('Erro ao obter competi√ß√µes:', erro);
    return res.status(500).json({ 
      erro: 'Erro interno do servidor', 
      detalhes: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para listar todos os n√≠veis
app.get('/api/niveis', (req, res) => {
  try {
    const data = req.query.data;
    console.log('Solicita√ß√£o de lista de n√≠veis');
    const dados = obterDadosJogos(data);
    
    const niveis = obterNiveis(dados.jogos);
    
    return res.json({
      total: niveis.length,
      niveis: niveis,
      data: dados.data,
      timestamp: new Date().toISOString()
    });
  } catch (erro) {
    console.error('Erro ao obter n√≠veis:', erro);
    return res.status(500).json({ 
      erro: 'Erro interno do servidor', 
      detalhes: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para listar todos os times
app.get('/api/times', (req, res) => {
  try {
    const data = req.query.data;
    console.log('Solicita√ß√£o de lista de times');
    const dados = obterDadosJogos(data);
    
    const times = obterTimes(dados.jogos);
    
    return res.json({
      total: times.length,
      times: times,
      data: dados.data,
      timestamp: new Date().toISOString()
    });
  } catch (erro) {
    console.error('Erro ao obter times:', erro);
    return res.status(500).json({ 
      erro: 'Erro interno do servidor', 
      detalhes: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para atualizar dados (executar scraping sob demanda)
app.post('/api/atualizar', async (req, res) => {
  try {
    console.log('üîÑ Iniciando scraping sob demanda...');
    
    // Executar o scraping adaptativo
    await scrapingAdaptativo();
    
    // Aguardar um pouco para garantir que o arquivo foi salvo
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Tentar obter os dados atualizados
    const dados = obterDadosJogos();
    
    if (dados.observacao && dados.observacao.includes('exemplo')) {
      return res.status(202).json({
        status: 'parcial',
        mensagem: 'O scraping foi executado, mas ainda n√£o h√° dados atualizados dispon√≠veis',
        dados: dados,
        timestamp: new Date().toISOString()
      });
    }
    
    return res.json({
      status: 'sucesso',
      mensagem: 'Dados atualizados com sucesso via scraping',
      totalJogos: dados.totalJogos,
      dados: dados,
      timestamp: new Date().toISOString()
    });
    
  } catch (erro) {
    console.error('‚ùå Erro ao executar scraping:', erro);
    return res.status(500).json({
      status: 'erro',
      mensagem: 'Erro ao executar o scraping',
      erro: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para iniciar atualiza√ß√£o autom√°tica
app.post('/api/atualizar/iniciar', (req, res) => {
  try {
    if (intervalAtualizacao) {
      return res.json({
        status: 'info',
        mensagem: 'Atualiza√ß√£o autom√°tica j√° est√° ativa',
        intervalo: `${INTERVALO_ATUALIZACAO} minutos`,
        ultimaAtualizacao: ultimaAtualizacao ? ultimaAtualizacao.toISOString() : null,
        timestamp: new Date().toISOString()
      });
    }
    
    iniciarAtualizacaoAutomatica();
    
    return res.json({
      status: 'sucesso',
      mensagem: 'Atualiza√ß√£o autom√°tica iniciada com sucesso',
      intervalo: `${INTERVALO_ATUALIZACAO} minutos`,
      timestamp: new Date().toISOString()
    });
    
  } catch (erro) {
    console.error('‚ùå Erro ao iniciar atualiza√ß√£o autom√°tica:', erro);
    return res.status(500).json({
      status: 'erro',
      mensagem: 'Erro ao iniciar atualiza√ß√£o autom√°tica',
      erro: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para parar atualiza√ß√£o autom√°tica
app.post('/api/atualizar/parar', (req, res) => {
  try {
    if (!intervalAtualizacao) {
      return res.json({
        status: 'info',
        mensagem: 'Atualiza√ß√£o autom√°tica j√° est√° inativa',
        timestamp: new Date().toISOString()
      });
    }
    
    pararAtualizacaoAutomatica();
    
    return res.json({
      status: 'sucesso',
      mensagem: 'Atualiza√ß√£o autom√°tica parada com sucesso',
      timestamp: new Date().toISOString()
    });
    
  } catch (erro) {
    console.error('‚ùå Erro ao parar atualiza√ß√£o autom√°tica:', erro);
    return res.status(500).json({
      status: 'erro',
      mensagem: 'Erro ao parar atualiza√ß√£o autom√°tica',
      erro: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para iniciar atualiza√ß√£o di√°ria
app.post('/api/atualizar/diaria/iniciar', (req, res) => {
  try {
    if (cronJobDiario) {
      return res.json({
        status: 'info',
        mensagem: 'Atualiza√ß√£o di√°ria j√° est√° ativa',
        horario: 'Meia-noite (00:00)',
        cronExpression: HORARIO_ATUALIZACAO_DIARIA,
        timezone: 'America/Sao_Paulo',
        ultimaAtualizacao: ultimaAtualizacao ? ultimaAtualizacao.toISOString() : null,
        timestamp: new Date().toISOString()
      });
    }
    
    iniciarAtualizacaoDiaria();
    
    return res.json({
      status: 'sucesso',
      mensagem: 'Atualiza√ß√£o di√°ria iniciada com sucesso',
      horario: 'Meia-noite (00:00)',
      cronExpression: HORARIO_ATUALIZACAO_DIARIA,
      timezone: 'America/Sao_Paulo',
      timestamp: new Date().toISOString()
    });
    
  } catch (erro) {
    console.error('‚ùå Erro ao iniciar atualiza√ß√£o di√°ria:', erro);
    return res.status(500).json({
      status: 'erro',
      mensagem: 'Erro ao iniciar atualiza√ß√£o di√°ria',
      erro: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Rota para parar atualiza√ß√£o di√°ria
app.post('/api/atualizar/diaria/parar', (req, res) => {
  try {
    if (!cronJobDiario) {
      return res.json({
        status: 'info',
        mensagem: 'Atualiza√ß√£o di√°ria j√° est√° inativa',
        timestamp: new Date().toISOString()
      });
    }
    
    pararAtualizacaoDiaria();
    
    return res.json({
      status: 'sucesso',
      mensagem: 'Atualiza√ß√£o di√°ria parada com sucesso',
      timestamp: new Date().toISOString()
    });
    
  } catch (erro) {
    console.error('‚ùå Erro ao parar atualiza√ß√£o di√°ria:', erro);
    return res.status(500).json({
      status: 'erro',
      mensagem: 'Erro ao parar atualiza√ß√£o di√°ria',
      erro: erro.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Tratamento de erros globais
process.on('uncaughtException', (err) => {
  console.error('Erro n√£o capturado:', err);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Promise rejeitada n√£o tratada:', reason);
});

// Iniciar o servidor
const server = app.listen(PORT, '0.0.0.0', () => {
  console.log('\n' + '='.repeat(80));
  console.log('üöÄ API DE JOGOS - VERS√ÉO DEPLOY APRIMORADA v2.1!');
  console.log('='.repeat(80));
  console.log(`üì° Porta: ${PORT}`);
  console.log(`üåê URL Local: http://localhost:${PORT}`);
  console.log(`üåç URL Externa: Ser√° fornecida pelo servi√ßo de hospedagem`);
  console.log(`\nüìã Endpoints principais:`);
  console.log(`   ‚úÖ GET  / - P√°gina inicial com documenta√ß√£o`);
  console.log(`   ‚úÖ GET  /health - Health check`);
  console.log(`   ‚úÖ GET  /api/status - Status da API`);
  console.log(`   ‚úÖ GET  /api/jogos - Jogos da data atual`);
  console.log(`\nüéØ Endpoints de filtros:`);
  console.log(`   üÜï GET  /api/jogos/data/:data - Jogos por data (YYYY-MM-DD)`);
  console.log(`   üÜï GET  /api/jogos/competicao/:nome - Jogos por competi√ß√£o`);
  console.log(`   üÜï GET  /api/jogos/nivel/:nome - Jogos por n√≠vel`);
  console.log(`   üÜï GET  /api/jogos/time/:nome - Jogos por time`);
  console.log(`\nüìä Endpoints de listagem:`);
  console.log(`   üìã GET  /api/competicoes - Lista todas as competi√ß√µes`);
  console.log(`   üìã GET  /api/niveis - Lista todos os n√≠veis`);
  console.log(`   üìã GET  /api/times - Lista todos os times`);
  console.log(`\nüîÑ Endpoints de atualiza√ß√£o:`);
  console.log(`   üÜï POST /api/atualizar - Executar scraping manual`);
  console.log(`   üÜï POST /api/atualizar/iniciar - Iniciar atualiza√ß√£o autom√°tica`);
  console.log(`   üÜï POST /api/atualizar/parar - Parar atualiza√ß√£o autom√°tica`);
  console.log(`   üåô POST /api/atualizar/diaria/iniciar - Iniciar atualiza√ß√£o di√°ria`);
  console.log(`   üåô POST /api/atualizar/diaria/parar - Parar atualiza√ß√£o di√°ria`);
  console.log(`\nüîç Query Parameters dispon√≠veis:`);
  console.log(`   ‚Ä¢ ?competicao=nome - Filtrar por competi√ß√£o`);
  console.log(`   ‚Ä¢ ?nivel=nome - Filtrar por n√≠vel`);
  console.log(`   ‚Ä¢ ?time=nome - Filtrar por time`);
  console.log(`   ‚Ä¢ ?status=status - Filtrar por status`);
  console.log(`   ‚Ä¢ ?data=YYYY-MM-DD - Para endpoints de listagem`);
  console.log(`\nüí° Exemplos de uso:`);
  console.log(`   üîó /api/jogos?competicao=Copa`);
  console.log(`   üîó /api/jogos?time=Flamengo`);
  console.log(`   üîó /api/jogos/data/2025-07-30?competicao=Copa&time=Corinthians`);
  console.log(`\nüîß Configura√ß√µes ativas:`);
  console.log(`   ‚Ä¢ CORS habilitado para TODAS as origens`);
  console.log(`   ‚Ä¢ Logs detalhados de requisi√ß√µes`);
  console.log(`   ‚Ä¢ Trust proxy habilitado`);
  console.log(`   ‚Ä¢ Health check para monitoramento`);
  console.log(`   ‚Ä¢ Sistema de filtros avan√ßado`);
  console.log(`   ‚Ä¢ Valida√ß√£o de par√¢metros`);
  console.log(`   ‚Ä¢ Dados de exemplo quando arquivo n√£o existe`);
  console.log(`   ‚Ä¢ Atualiza√ß√£o autom√°tica a cada ${INTERVALO_ATUALIZACAO} minutos`);
  console.log(`   ‚Ä¢ Atualiza√ß√£o di√°ria √† meia-noite (timezone: America/Sao_Paulo)`);
  console.log(`\nüí° Pronto para deploy em:`);
  console.log(`   ‚Ä¢ Render.com`);
  console.log(`   ‚Ä¢ Railway.app`);
  console.log(`   ‚Ä¢ Vercel.com`);
  console.log(`   ‚Ä¢ Heroku`);
  console.log(`\nüåô Iniciando sistema de atualiza√ß√£o di√°ria...`);
  
  // Iniciar atualiza√ß√£o di√°ria (principal)
  iniciarAtualizacaoDiaria();
  
  console.log(`\nüïê Sistema de atualiza√ß√£o por intervalo dispon√≠vel via API...`);
  console.log(`   Use POST /api/atualizar/iniciar para ativar atualiza√ß√£o por intervalo`);
  
  console.log(`\n‚è≥ Aguardando requisi√ß√µes...`);
  console.log('='.repeat(80));
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('\nüõë Recebido SIGTERM, encerrando servidor...');
  server.close(() => {
    console.log('‚úÖ Servidor encerrado com sucesso.');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('\nüõë Recebido SIGINT (Ctrl+C), encerrando servidor...');
  server.close(() => {
    console.log('‚úÖ Servidor encerrado com sucesso.');
    process.exit(0);
  });
});

// Export para compatibilidade com alguns servi√ßos
module.exports = app;